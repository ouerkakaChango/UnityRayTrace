// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Render

#include "../HLSL/RayMath.hlsl"
//???
#include "../HLSL/Scenes/IBLSceneInfo.hlsl"
#include "../HLSL/SDFGame/SDFGameScene1.hlsl"

int w;
int h;

//#########################################################################################################
int Inx2D(int i, int j)
{
	return i + w * j;
}
//#########################################################################################################
float3 screenLeftDownPix;
float3 eyePos;
float pixW;
float pixH;
float3 screenU;
float3 screenV;

RWTexture2D<float4> Result;
Texture2D<float4> envDiffTex;
Texture2DArray envSpecTex2DArr;
Texture2D<float4> brdfLUT;
Texture2D<float4> envBgTex;

//#########################################################################################################
#define MAXLEAVES 32
[numthreads(8, 8, 1)]
void Render(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	Ray ray;
	ray.pos = screenLeftDownPix + screenU * i * pixW + screenV * j * pixH;
	ray.dir = normalize(ray.pos - eyePos);

	//---Trace
	HitInfo minHit;
	Init(minHit);
	SDFScene(ray, minHit);
	//___Trace
	
	float3 re = 0; 
	if (minHit.bHit)
	{//Trace到Mesh了，返回Mesh的颜色 
		//???
		minHit.obj = 0;

		Material_PBR mat = GetObjMaterial_PBR(minHit.obj);
		re = PBR_IBL(envDiffTex, envSpecTex2DArr, brdfLUT, mat, minHit.N, -ray.dir);
	}
	else
	{//没Trace到，返回背景/天空盒的颜色

		re = 1;//GetEnvIrradiance_equirectangular(envBgTex, ray.dir, true);
	}

	Result[id.xy] = float4(re, 1);
}