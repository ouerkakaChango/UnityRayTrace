// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitRays
#pragma kernel Trace
#pragma kernel Bounce
#pragma kernel GatherSublight

#define PI 3.14159f

int BI;

RWTexture2D<float4> Result;

int SPP;
float w;
float h;

struct Ray
{
	float3 pos;
	float3 dir;
};
RWStructuredBuffer<Ray> mainRays;
RWStructuredBuffer<Ray> subRays;

struct HitInfo
{
	int bHit;
	int obj;
	float3 N;
	float3 P;
};
RWStructuredBuffer<HitInfo> hitInfos;
RWStructuredBuffer<HitInfo> mainHits;
RWStructuredBuffer<HitInfo> subHits;

struct Light
{
	float3 color;
};
RWStructuredBuffer<Light> subLights;

#include "../HLSL/SDF/SDFScene.hlsl"
#include  "../HLSL/Random/RandUtility.hlsl"

[numthreads(8, 8, 1)]
void InitRays(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	float maxTraceDis = 10.0f;
	float traceThre = 0.01f;

	float3 screenPos = float3(0, 0, 0);
	float3 eyeOffset = float3(0, 0, 1);
	float dx = 2.0f / w;
	float ylen = dx * h;
	float3 screenLeftDownPos = float3(-1, -ylen / 2, 0) + 0.5f*float3(dx, dx, 0);

	Ray ray;
	HitInfo hit;
	//初始化
	hit.bHit = 0;
	//######################## 
	ray.pos = screenPos + screenLeftDownPos + float3(i*dx, j*dx, 0);
	ray.dir = ray.pos - screenPos - eyeOffset; //默认eyePos在屏幕后一单位，z轴向屏幕外为(0,0,1)

	SDFScene(ray,hit);

	//在hit上初始化SPP个subRay
	for (int k = 0; k < SPP; k++)
	{
		Ray subRay;
		float3 seed = hit.P + float3(i, j, k);
		subRay.dir = normalize(randP_round(seed) + hit.N);
		subRay.pos = hit.P;
		subRays[i + w * j + w * h * k] = subRay;
	}
	//######################## 
	//end
	mainRays[i + w * j] = ray;
	mainHits[i + w * j] = hit;

	float3 re = 0;
	re = GetObjEmissive(hit.obj);
	//Result[id.xy] = float4(mainRays[i + w * j].pos, 0);
	//Result[id.xy] = float4(subRays[i + w * j].dir, 0);
	Result[id.xy] = float4(hit.N, 0);
	//Result[id.xy] = float4(hit.P, 0);
	//Result[id.xy] = float4(re, 0);
}
//#########################################################################################################
[numthreads(8, 8, 1)]
void Trace(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	HitInfo hit = subHits[i + w * j + w * h * 0 + w * h* SPP * BI];
	//######################## 
	for (int k = 0; k < SPP; k++)
	{
		Ray ray = subRays[i + w * j + w * h * k];
		//初始化
		hit.bHit = 0;
		SDFScene(ray, hit);
		subHits[i + w * j + w * h * k + w * h* SPP * BI] = hit;
	}
	//######################## 

	float3 re = float3(0, 0, 0);
	re = subHits[i + w * j + w * h * 0 + w * h* SPP * BI].bHit;
	Result[id.xy] = float4(re, 0);
}
//############################################################################
[numthreads(8, 8, 1)]
void Bounce(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;
	//######################## 
	for (int k = 0; k < SPP; k++)
	{
		Ray ray = subRays[i + w * j + w * h * k];
		HitInfo hit = subHits[i + w * j + w * h * k + w * h* SPP * BI];
		ray.dir = reflect(ray.dir, hit.N);
	}
	//######################## 
	//end
	float3 re = float3(0, 0, 0);
	re = subRays[i + w * j + w * h * 0].dir;
	Result[id.xy] = float4(re, 0);
}
//############################################################################
float dis2(float3 p1, float3 p2)
{
	float3 d = p1 - p2;
	return dot(d, d);
}

float3 GetAttenuationed(float3 lightColor, float3 pos, float3 lightPos)
{
	float ldis2 = dis2(pos, lightPos);
	float attenuation = 1.0;
	//按光学原理， atten 正比 1/dis2
	//防止距离太近的时候除爆了，衰减亮度需要一个最小值
	float d2min = 0.01;
	float d2max = 20;
	if (ldis2 > d2min)
	{
		attenuation = (d2max - ldis2) / (d2max - d2min);
	}
	attenuation = saturate(attenuation);

	return attenuation * lightColor;
}

float3 fresnelSchlick(float cosTheta, float3 F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
	float r = (roughness + 1.0);
	float k = (r*r) / 8.0;

	float nom = NdotV;
	float denom = NdotV * (1.0 - k) + k;

	return nom / denom;
}

float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
{
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	float ggx2 = GeometrySchlickGGX(NdotV, roughness);
	float ggx1 = GeometrySchlickGGX(NdotL, roughness);

	return ggx1 * ggx2;
}

float DistributionGGX(float3 N, float3 H, float roughness)
{
	float a = roughness * roughness;
	float a2 = a * a;
	float NdotH = max(dot(N, H), 0.0);
	float NdotH2 = NdotH * NdotH;

	float nom = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = PI * denom * denom;

	return nom / denom;
}

struct Material_PBR
{
	float3 albedo;
	float metallic;
	float roughness;
};

float3 PBR_GGX(Material_PBR param, float3 n, float3 v, float3 l, float3 Li)
{
	float3 h = normalize(l + v);

	//Calculate F
	float3 F0 = 0.04;
	F0 = lerp(F0, param.albedo, param.metallic);
	float3 F = fresnelSchlick(max(dot(h, v), 0.0), F0);

	//Calculate diffuse
	float3 kD = 1.0 - F;
	float3 diffuse = (1.0 - param.metallic) * kD * param.albedo / PI;

	//Calculate specular
	float G = GeometrySmith(n, v, l, param.roughness);
	float3 nominator;
	float NDF = DistributionGGX(n, h, param.roughness);
	nominator = NDF * G * F;
	float denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.001;
	float3 specular = nominator / denominator;

	float3 Lo = diffuse + specular;
	Lo *= Li * max(dot(n, l), 0);

	return Lo;
}

Material_PBR GetObjMaterial_PBR(int obj)
{
	Material_PBR re;
	if (obj == 0)
	{
		re.albedo = float3(1, 1, 1);
		re.metallic = 0.01;
		re.roughness = 0.98;
		//re.metallic = 0.7;
		//re.roughness = 0.3;
	}
	else if (obj >= 1 && obj<=5)
	{
		re.albedo = float3(1, 1, 1);
		if (obj == 3)
		{
			re.albedo = float3(1, 0, 0);
		}
		if (obj == 4)
		{
			re.albedo = float3(0, 1, 0);
		}
		re.metallic = 0.01;
		re.roughness = 0.98;
	}
	else if (obj == 6)
	{
		//re.emissive = 1;
	}
	else
	{//错误材质色，类似unity中的麦金塔色
		re.albedo = float3(1, 1, 0);
		re.metallic = 0;
		re.roughness = 1;
	}

	return re;
}

[numthreads(8, 8, 1)]
void GatherSublight(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	//######################## 
	for (int k = 0; k < SPP; k++)
	{
		Light light = subLights[i + w * j + w * h * k];
		light.color = 0;
		for (int inx = BI; inx >= 0; inx--)
		{
			HitInfo hit = subHits[i + w * j + w * h * k + w*h*SPP*inx];
			if (inx == BI)
			{
				light.color = GetObjEmissive(hit.obj);
			}
			else
			{
				//???
				//light[inx] = ObjEmissive(hit[inx]) + PBR(light[inx+1],hit[inx])
			}
		}
		subLights[i + w * j + w * h * k] = light;
	}
	//######################## 
	//end
	float3 re = 0; 
	float3 tt = 0;
	for (int k = 0; k < SPP; k++)
	{
		Light light = subLights[i + w * j + w * h * k];
		tt += light.color;
	}
	re = tt;
	Result[id.xy] = float4(re, 0);
}