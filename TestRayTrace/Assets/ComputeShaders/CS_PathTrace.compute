// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitRaysBlock
#pragma kernel TraceBlock
#pragma kernel BounceBlock
#pragma kernel RenderBlock

//根据网上资料，N卡最小也有32threads，A卡64
//所以 Use 64 threads (e.g. (64, 1, 1), (8, 8, 1), (16, 2, 2) etc.)
//threads数量过低会慢很多
#define CoreX 8
#define CoreY 8

#define PI 3.14159f

int BI;

RWTexture2D<float4> Result;

int SPP;
int w;
int h;
int cw;
int ch;
int blockX;
int blockY;

struct Ray
{
	float3 pos;
	float3 dir;
};
RWStructuredBuffer<Ray> mainRays;
RWStructuredBuffer<Ray> subRays;

struct HitInfo
{
	int bHit;
	int obj;
	float3 N;
	float3 P;
};
RWStructuredBuffer<HitInfo> hitInfos;
RWStructuredBuffer<HitInfo> mainHits;
RWStructuredBuffer<HitInfo> subHits;

struct Light
{
	float3 color;
};
RWStructuredBuffer<Light> subLights;

#include "../HLSL/SDF/SDFScene.hlsl"
#include  "../HLSL/Random/RandUtility.hlsl"
#include "../HLSL/Render/Light.hlsl"
#include "../HLSL/Render/PBR.hlsl"

int Inx2D(int i, int j)
{
	return i + cw * j;
}

int Inx3D(int i, int j, int k)
{
	return i + cw * j + cw * ch*k;
}

int Inx4D(int i, int j, int k, int bounceInx)
{
	return i + cw * j + cw * ch*k + cw*ch*SPP * bounceInx;
}

float2 Inx_img(int i, int j)
{
	return float2(i+ blockX * cw,j+ blockY * ch);
}

//#########################################################################################################
[numthreads(CoreX, CoreY, 1)]
void InitRaysBlock(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	float3 screenPos = float3(0, 0, 0);
	float3 eyeOffset = float3(0, 0, 1);
	float dx = 2.0f / w;
	float ylen = dx * h;
	float3 screenLeftDownPos = float3(-1, -ylen / 2, 0) + 0.5f*float3(dx, dx, 0);
	float3 blockOffset = float3(blockX*cw*dx, blockY*ch*dx, 0);

	Ray ray;
	HitInfo hit;
	//初始化
	hit.bHit = 0;
	//######################## 
	ray.pos = screenPos + screenLeftDownPos + float3(i*dx, j*dx, 0) + blockOffset;
	ray.dir = ray.pos - screenPos - eyeOffset; //默认eyePos在屏幕后一单位，z轴向屏幕外为(0,0,1)

	SDFScene(ray,hit);

	//在hit上初始化SPP个subRay
	for (int k = 0; k < SPP; k++)
	{
		Ray subRay;
		float3 seed = hit.P + float3(i, j, k) + float3(blockX, blockY,0);
		{
			//type1
			subRay.dir = normalize(randP_round(seed) + hit.N);
			//type2 uni 
			//subRay.dir = randP_halfRound(seed, hit.N);
			{//type3 Importance Sample (GGX NDF2)
				//1.prepare a
				Material_PBR param = GetObjMaterial_PBR(hit.obj);
				float a = param.roughness;
				a = max(0.001f, a*a);
				//2.sample h 
				float x1 = rand01(seed);
				float x2 = rand01(seed.zxy);
				float phi = 2 * PI*x1;
				float costheta = sqrt((1 - x2) / (1 + (a*a - 1)*x2));
				float sintheta = sqrt(1 - costheta * costheta);
				float3 H = float3(
					sintheta*cos(phi),
					sintheta*sin(phi),
					costheta);
				H = toNormalHemisphere(H, hit.N);
				subRay.dir = reflect(-ray.dir, H);
			}
			{
				////type4 Importance Sample (Diffuse)
				////1.prepare a
				//Material_PBR param = GetObjMaterial_PBR(hit.obj);
				//float a = param.roughness;
				//a = max(0.001f, a*a);
				////2.sample h 
				//float x1 = rand01(seed);
				//float x2 = rand01(seed.zxy);
				//float r = sqrt(x1);
				//float theta = x2 * 2 * PI;
				//float x = r * cos(theta);
				//float y = r * sin(theta);
				//float z = sqrt(1 - x * x - y * y);
				//float3 H = float3(x, y, z);
				//H = toNormalHemisphere(H, hit.N);
				//subRay.dir = reflect(-ray.dir, H);
			}
			{//type3 Importance Sample(GGX NDF1)
				//1.prepare a
				//Material_PBR param = GetObjMaterial_PBR(hit.obj);
				//float a = param.roughness;
				//a = max(0.001f, a*a);
				////2.sample h 
				//float x1 = rand01(seed);
				//float x2 = rand01(seed.zxy*seed.z);
				//float phi = 2 * PI*x1;
				//float theta = atan(a*sqrt(x2 / (1 - x2)));
				//float3 H = PFromSpherical(theta, phi,1);
				////???
				//H = toNormalHemisphere(H, hit.N);
				//subRay.dir = reflect(-ray.dir, H);
			}
		}
		subRay.pos = hit.P;
		subRays[Inx3D(i,j,k)] = subRay;
	}
	//######################## 
	//end
	mainRays[Inx2D(i,j)] = ray;
	mainHits[Inx2D(i, j)] = hit;

	float3 re = 0;
	re = hit.N;
	Result[Inx_img(i, j)] = float4(re, 0);
}
//#########################################################################################################
int traceInx;
int SPP_cell;
[numthreads(CoreX, CoreY, 1)]
void TraceBlock(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	HitInfo hit;// = subHits[Inx4D(i, j, 0, BI)];
	//######################## 
	for (int k = traceInx*SPP_cell; k < (traceInx+1)*SPP_cell; k++)
	{
		Ray ray = subRays[Inx3D(i,j,k)];
		//初始化
		hit.bHit = 0;
		SDFScene(ray, hit);
		subHits[Inx4D(i, j, k, BI)] = hit;
	}
	//######################## 

	float3 re = float3(0, 0, 0);

	re = subHits[Inx4D(i, j, 0, BI)].P;
	Result[Inx_img(i, j)] = float4(re, 0);
}
//############################################################################
[numthreads(CoreX, CoreY, 1)]
void BounceBlock(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;
	//######################## 
	for (int k = 0; k < SPP; k++)
	{
		Ray ray = subRays[Inx3D(i, j, k)];
		HitInfo hit = subHits[Inx4D(i, j, k, BI)];
		float3 seed = hit.P + float3(i, j, k) + float3(blockX, blockY, 0);
		Material_PBR param = GetObjMaterial_PBR(hit.obj);
		float3 ref = reflect(ray.dir, hit.N);
		ray.dir = normalize(randP_round(seed) + ref);
		//subRay.dir = randP_halfRound(seed, hit.N);
		subRays[Inx3D(i, j, k)] = ray;
	}
	//######################## 
	//end
	float3 re = float3(0, 0, 0);
	re = subRays[Inx3D(i, j, 0)].dir;
	//re = abs(subRays[Inx3D(i, j, 0)].pos);
	Result[Inx_img(i, j)] = float4(re, 0);
}
//############################################################################

//#################################################################
Light ShadeSublight(Light light, HitInfo preHit, HitInfo hit, HitInfo nextHit)
{
	float3 Li = GetAttenuationed(light.color, hit.P, nextHit.P);
	Material_PBR param = GetObjMaterial_PBR(hit.obj);
	float3 V = normalize(preHit.P - hit.P);
	float3 L = normalize(nextHit.P - hit.P);
	float3 c = PBR_GGX(param, hit.N, V, L, Li);

	Light re;
	//??? 吸收系数
	re.color = GetObjEmissive(hit.obj) + c;
	return re;
}

[numthreads(CoreX, CoreY, 1)]
void RenderBlock(uint3 id : SV_DispatchThreadID)
{
	int i = id.x;
	int j = id.y;

	int k = 0;
	float3 finalColor = 0;
	HitInfo mainHit = mainHits[Inx2D(i,j)];
	Ray mainRay = mainRays[Inx2D(i, j)];
	int subRayValid = 0;
	//######################## 
	Material_PBR mainParam = GetObjMaterial_PBR(mainHit.obj);
	float a = mainParam.roughness;
	a = max(0.001f, a*a);

	for (k = 0; k < SPP; k++)
	{
		Light light;
		light.color = 0;
		subRayValid = 0;
		for (int inx = BI; inx >= 0; inx--)
		{
			HitInfo hit = subHits[Inx4D(i,j,k,inx)];
			if (inx == BI)
			{
				light.color = GetObjEmissive(hit.obj);
				if (rgbSum(GetObjEmissive(hit.obj)) > 0)
				{
					Result[Inx_img(i, j)] = float4(light.color, 0);
					subRayValid = 1;
				}
			}
			else if (inx == 0)
			{
				HitInfo preHit = mainHits[Inx2D(i, j)];
				HitInfo nextHit = subHits[Inx4D(i, j, k, inx + 1)];
				light = ShadeSublight(light, preHit, hit, nextHit);
				if (rgbSum(GetObjEmissive(hit.obj)) > 0)
				{
					Result[Inx_img(i, j)] = float4(light.color, 0);
					subRayValid = 1;
				}
			}
			else
			{
				HitInfo preHit = subHits[Inx4D(i, j, k, inx - 1)];
				HitInfo nextHit = subHits[Inx4D(i, j, k, inx + 1)];
				light = ShadeSublight(light, preHit, hit, nextHit);
				if (rgbSum(GetObjEmissive(hit.obj)) > 0)
				{
					Result[Inx_img(i, j)] = float4(light.color, 0);
					subRayValid = 1;
				}
			}
		}

		//2.
		if (subRayValid == 1)
		{			
			HitInfo firstHit = subHits[Inx4D(i, j, k, 0)];
			float3 N = mainHit.N;
			float3 V = -mainRay.dir;
			float3 L = normalize(firstHit.P - mainHit.P);
			float3 Li = GetAttenuationed(light.color, mainHit.P, firstHit.P);
			Material_PBR param = GetObjMaterial_PBR(mainHit.obj);
			float pdf = 1;
			{
				//type1
				//pdf = 1/(2*PI);
				{//type3 Importance Sample(NDF2)					
					float3 H = normalize(V + L);
					float theta = acos(dot(N, H));
					float c = cos(theta);
					
					float nomi = a * a * c;
					float deno = c * c * (a*a - 1) + 1;
					pdf = nomi / deno;
					pdf /= 4 * dot(L, H);
				}
				{//type4 Importance Sample(Diffuse)
					//float3 H = normalize(V + L);
					//pdf = dot(N, H) / PI;
				}
				{//type3 Importance Sample(NDF1)					
					//float3 H = normalize(V + L);
					//float theta = acos(dot(N, H));
					//theta = lerp(0.00001, PI / 2, theta / (PI / 2));
					//float c = cos(theta);
					//float s = sin(theta);
					//
					//float nomi = 2*a * a * c*s;
					//float deno = c * c * (a*a - 1) + 1;
					//pdf = nomi / deno;
				}
			}
			finalColor += PBR_GGX(param, N, V, L, Li)/pdf;
		}
	}
	finalColor = finalColor / SPP;
	finalColor += GetObjEmissive(mainHit.obj);
	//???
	finalColor = pow(abs(finalColor), 1.0f / 2.2f);
	//######################## 
	//end
	float3 re = 0; 
	re = finalColor;
	//re = -cross(float3(0, 1, 0), float3(1, 0, 0));
	//re = toNormalHemisphere(float3(1, 1, 1), float3(0, 0, 1));
	Result[Inx_img(i, j)] = float4(re, 0);
}